# HashMap

![Image](https://habrastorage.org/storage1/4e3e57f4/aaa0b3fd/c697a3d8/5108f778.png)

*HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не дает гарантий относительно порядка элементов с течением времени. Разрешение коллизий осуществляется с помощью метода цепочек.*

### Создание объекта

`Map<String, String> hashmap = new HashMap<String, String>();`

Объект hashmap, содержит ряд свойств:
+ **table** — Массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений;
+ **loadFactor** -  Коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных;
+ **threshold** - Предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое. Рассчитывается по формуле (**capacity * loadFactor**);
+ **size** — Количество элементов HashMap-а;

Указать свою емкость и коэффициент загрузки, используя конструкторы `HashMap(capacity)` и `HashMap(capacity, loadFactor)`. Максимальная емкость, которую вы сможете установить, равна половине максимального значения int (1073741824).

### Добавление элементов

`hashmap.put("0", "zero");`

Последовательность шагов следующая:
1. Сначала ключ проверяется на равенство null. Если это проверка вернула true, будет вызван метод `putForNullKey(value)` (вариант с добавлением null-ключа чуть позже).
2. Далее генерируется хэш на основе ключа. Для генерации используется метод `hash(hashCode)`, в который передается `key.hashCode()`.
3. С помощью метода `indexFor(hash, tableLength)`, определяется позиция в массиве, куда будет помещен элемент.
4. Зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается.
5. Если же предыдущий шаг не выявил совпадений, будет вызван метод `addEntry(hash, key, value, index)` для добавления нового элемента.


Если при добавлении элемента в качестве ключа был передан `null`, действия будут отличаться. Будет вызван метод `putForNullKey(value)`, внутри которого нет вызова методов `hash()` и `indexFor()` (потому как все элементы с null-ключами всегда помещаются в **table[0]**), но есть такие действия:
1. Все элементы цепочки, привязанные к **table[0]**, поочередно просматриваются в поисках элемента с ключом `null`. Если такой элемент в цепочке существует, его значение перезаписывается.
2. Если элемент с ключом null не был найден, будет вызван  метод `addEntry()`.


### Resize и Transfer

Когда массив `table[]` заполняется до предельного значения, его размер увеличивается вдвое и происходит перераспределение элементов.

Метод `transfer()` перебирает все элементы текущего хранилища, пересчитывает их индексы (с учетом нового размера) и перераспределяет элементы по новому массиву.

Если в исходный hashmap добавить, скажем, еще 15 элементов, то в результате размер будет увеличен и распределение элементов изменится.


### Удаление элементов

У HashMap есть такая же «проблема» как и у ArrayList — при удалении элементов размер массива **table[]** не уменьшается.


### Итераторы

Чтобы получить список всех ключей `keySet()`, всех значений `values()` или же все пары ключ/значение `entrySet()`. Ниже представлены некоторые варианты для перебора элементов:

```
// 1.
for (Map.Entry<String, String> entry: hashmap.entrySet())
    System.out.println(entry.getKey() + " = " + entry.getValue());

// 2.
for (String key: hashmap.keySet())
    System.out.println(hashmap.get(key));

// 3.
Iterator<Map.Entry<String, String>> itr = hashmap.entrySet().iterator();
while (itr.hasNext())
    System.out.println(itr.next());
```

Стоит помнить, что если в ходе работы итератора HashMap был изменен (без использования собственным методов итератора), то результат перебора элементов будет непредсказуемым. 

### Итоги

- Добавление элемента выполняется за время O(1), потому как новые элементы вставляются в начало цепочки;
- Операции получения и удаления элемента могут выполняться за время O(1), если хэш-функция равномерно распределяет элементы и отсутствуют коллизии. Среднее же время работы будет Θ(1 + α), где α — коэффициент загрузки. В самом худшем случае, время выполнения может составить Θ(n) (все элементы в одной цепочке);
- Ключи и значения могут быть любых типов, в том числе и null. Для хранения примитивных типов используются соответствующие классы-оберки;
- Не синхронизирован.


### Ссылки
[original page](https://habrahabr.ru/post/128017/)

ООП
=================
# Основные понятия

**ООП** — это одна из парадигм (методологий, подходов) программирования, основанная на принципах, предполагающих написание программного кода в виде классов и их объектов, взаимодействующих друг с другом.

**Класс** — это составной (ссылочный) тип данных, являющийся прототипом (blueprint, шаблоном, моделью) объекта из какой-либо предметной области (сферы деятельности человека, но не обязательно), описывающий его состояние и реализующий его поведение.

**Объект** — это экземпляр какого-либо класса (расположенного в памяти), отражающий конкретную сущность программируемой предметной области (не всегда!), и обладающий внутренним состоянием в виде полей / атрибутов (fields) и поведением (функционалом) в виде методов (methods).

**Состояние объекта (state)** — это значения, которые принимают его поля (fields). Со сменой значения полей — меняется состояние объекта.

**Поведение объекта (behavior)** — это набор его методов (methods), которые могут изменять состояние объекта либо выполнять иные функции.

## Основные принципы ООП

**Абстракция** (лат. abstractio — отвлечение) — некое обобщение как результат абстрагирования.

**Программирование с помощью абстракции** — это написание кода с использованием абстрактных классов и интерфейсов, когда во внимание не берется реализация деталей, а выделяются лишь какие-то общие признаки на основании которых выстраивается иерархия наследования (уровни абстракции), основанная на базовых свойствах родительского класса.


**Инкапсуляция** — это механизм языка, позволяющий ограничить прямой доступ к полям и методам класса извне (другим классам), с целью запретить бесконтрольную модификацию состояния объекта или вызов методов, которые также могут изменить его состояние.

(public, private, protected)

***Достоинства***:

+ сокрытие реализации позволяет сократить временные затраты на поиск ошибок: если мы контролируем доступ к атрибуту, то при возникновении проблемы нам не придется беспокоиться об отслеживании каждого фрагмента кода, который мог бы изменить значение соответствующего атрибута — оно может быть изменено только в одном месте (с помощью сеттера);

+ также инкапсуляция заставляет пользователя играть по правилам, показывая ему только необходимые методы и скрывая не нужные;

+ инкапсуляция отделяет изменяемую часть класса от постоянной. Данное свойство полезно, т.к. позволяет безболезненно для пользователя менять код скрытых методов без каких-либо для него проблем, т.к. сигнатуры публичных методов, которые ему доступны, не меняются, а изменяются только скрытые (приватные) методы.

***Недостатки***:

+ необходимо писать дополнительный код в виде геттеров и сеттеров, которые зачастую захламляют код;

**Наследование** (англ. inheritance) — принцип, позволяющий создавать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование атрибутов и поведения, общих для классов, которые наследуют от него, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним, подклассом или производным классом.

В Java два вида наследования:

+ наследование классов: каждый наследник может иметь только одного родителя;
+ наследование интерфейсов: интерфейс может иметь сколько угодно родителей.

**Ограничения**

+ при наследовании доступ из методов класса-потомка к приватным полям родительского класса напрямую запрещен. Кроме того, данные поля не наследуются. Но благодаря специальным публичным методам, которые называются get/геттеры и set/сеттеры можно совершенно свободно обращаться к данным полям родительского класса из класса-потомка;

+ приватные методы, как и приватные поля также не наследуются. Это значит, что создание метода в классе-потомке с именем, аналогичным имени метода класса-предка — создаст совершенно новый метод и компилятор не предупредит вас об этом. Во избежание таких коллизий при наследовании методов желательно использовать аннотацию @Override. Благодаря данной аннотации компилятор сможет проконтролировать ваш код и выдать предупреждение, если переопределяемый метод не будет найден в родительском классе.

***Достоинства***

+ способствует уменьшению повторяемости кода, т.е. имеет место быть его переиспользование (англ. code reuse);

+ ускоряет разработку. тк наследование позволяет взять готовый класс, "клонировать" его в новый класс-потомок, т.е. получить весь функционал класса-предка, а затем расширить его, добавив новые методы и поля;

**Недостатки**

+ большое значение имеет правильное построение иерархии классов. Т.к на поздних этапах разработки, когда иерархия классов построена и на её основе разработано большое количество кода, оказывается трудно или даже невозможно внести какие-либо изменения в код базовых классов иерархии;

+ при внесении изменений в базовые классы — классы наследники об этом могут ничего не знать;

+ данный механизм требует, чтобы точный тип объекта был известен уже на стадии компиляции, что делает код, зависящим от реализации;

+ подкласс зависит от реализации родительского класса, что делает код сильно связанным.

**Полиморфизм** (многообразие форм) — возможность единообразно обрабатывать объекты с различной реализацией при условии наличия у них общего интерфейса или класса.
(Один интерфейс для множества реализаций)

По-простому: способность переменной вызывать нужные методы у объектов, имеющие разные типы (но находящиеся в одной иерархии). При этом происходит автоматический выбор нужного метода в зависимости от типа объекта.

**Ограничения**

+ Статические методы не поддерживают полиморфного поведения, т.к. они существуют на уровне класса, а не на уровне отдельных объектов

**Достоинства**

+ универсальность кода;

+ ускорение разработки, т.к. полиморфизм позволяет писать код, независящий от конкретных типов, находящихся в одной иерархии типов по отношению друг к другу. А это значит, что не нужно для каждого типа из этой иерархии писать дублирующий код;

+ снижение сложности программ, т.к. разрешая использование одного интерфейса для единого класса действий. При этом выбор конкретного действия, в зависимости от типа, возлагается на компилятор.


## Связывание

**Раннее связывание** (early binding) — это связывание, происходящее во время компиляции. Также его называют статическим.

**Позднее связывание** (late binding) — это связывание, которое выполняется во время выполнения программы. Его также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). При позднем связывании определяется фактический тип объекта для вызова именно его метода.

**Ограничение**

позднее связывание не работает для методов, объявленных, как final, private(?), static(?).

Связывание всех методов в Java осуществляется полиморфно, через позднее связывание — это значит, что мы можем писать код для базового класса, который будет работать во всех производных классах от него.

Пример:
```
Shape s = new Circle(); 
s.draw();
```
Тут нет ошибки, т.к. Окружность является, благодаря наследованию, Фигурой, а это уже восходящее преобразование.

s.draw(); — будет вызван метод не базового класса (Shape), а предка (Circle) благодаря позднему связыванию и полиморфизму.

### Что такое восходящее преобразование типов

**Восходящее преобразование (upcasting)** — это когда, например метод в качестве параметра типа базового класса принимает тип класса наследника. Но это разумно, т.к. класс наследник является разновидностью класса предка. Данный факт позволяет преобразовывать ссылку на объект наследника в ссылку на объект предка.


Восходящим оно называется потому, что стрелки наследования идут снизу вверх, более того корень иерархии всегда вверху. Данное преобразование безопасно, т.к. это по сути переход от конкретного типа к более общему, что часто ведет к потере методов, но не приобретению.

Преобразования можно делать и в обратном порядке — это называется **нисходящее преобразование (downcasting)**.



### Типы отношений между классами

Вся разница между агрегацией и композицией состоит в том, каким образом инициализируются поля в классе-контейнере и как эта инициализация влияет на время их жизни после смерти основного класса.

**Агрегация** (aggregation; «has-a» — есть, имеет, содержит) применяется когда один класс должен быть контейнером для других классов. Причем время существования содержащихся в нем классов (полей) никак не зависит от времени существования класса контейнера.

**Агрегация** — отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.


**Композиция** — еще более жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежать еще кому-то. Когда объект уничтожается, объекты, составляющие его, также уничтожаются.

*Пример этих видов связи из реального мира:
Возьмем отвертку. Если отвертка цельная, т.е. ручка и насадка намертво связаны друг с другом, то это композиция. Если же насадка съемная и может существовать без ручки или же использоваться с другой ручкой, то это агрегация.*

Композицию часто предпочитают наследованию
один из хороших критериев выбора между композицией и наследованием - спросить себя, собираетесь ли вы впоследствии проводить восходящее преобразование от производного класса к базовому.

![](https://user-images.githubusercontent.com/29703461/30761806-4ee00712-9fe8-11e7-8166-77b026e056d4.png)

## Достоинства ООП

+  более понятное представление структуры кода, основанное на сущностях предметной области, взятых из реального мира, что делает разработку более естественной для человека;

+ уменьшение сложности программного обеспечения;

+ повышение надежности программного обеспечения;

+ обеспечение возможности модификации отдельных компонентов программного обеспечения без изменения остальных его компонентов;

+ обеспечение возможности повторного использования отдельных компонентов программного обеспечения.


## Недостатки ООП

+ Неэффективность на этапе выполнения. 
+ Неэффективность в смысле распределения памяти. Динамическое связывание и проверка типа на этапе выполнения требуют по ходу работы информацию о типе объекта. Такая информация хранится в дескрипторе типа и он выделяется один на класс. Каждый объект имеет невидимый указатель на дескриптор типа для своего класса. Таким образом, в объектно-ориентированных программах необходимая дополнительная память выражается в одном указателе для объекта и в одном дескрипторе типа для класса.
+ Излишняя универсальность. Неэффективность также может означать, что в программе реализованы избыточные возможности. В библиотечном классе часто содержится больше методов, чем это реально необходимо. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом. Это не влияет на время выполнения, но сказывается на размере кода.




# Garbage Collector

## За что отвечает?

+ Обнаруживает мусор
+ Отвечает за очистку мусора

## Как обнаруживает мусор?

Два способа

+ Reference counting
+ Tracing

### Reference counting

Каждый объект имеет счетчик ссылок. Счетчик хранит информацию  сколько ссылок указывает на объект. Как только ссылка уничтожается. Счетчик омнимает еденицу, когда становится ноль. Объект считается мусором и его можно уничтожать.

Главным минусом такого подхола является сложность обеспечения точнсоти счетчика.Также сложно выявлять циклические зависимости (когда два объекта ссылаются друг на друг, а более нигде не используются). 

Reference counting используется редко.


### Tracing

Главная идея:  “Живые объект - те до которых мы можем добраться с корневых точек (GC Root), все остальные - мусор. Все что доступно с живого объекта - также живое”.

![](http://ggenikus.github.io/images/GC.gif)

При таком подходе легко выявить циклические зависимости. 

##### Что такое корневая точка(GC)?

Существует 4 вида точек:

+ Локальные переменные и параматры методов
+ Java потоки
+ Статические переменные
+ Ссылки из JNI

Самое простое java приложение будет иметь такие корневые точки:

+ Локальные переменные внутри main метода, параметры main метода.
+ Поток который выполняет main.
+ Статические переменные класса, внутри которого находится main метод.


## Как GC очищает память от мусора?

Рассмотрим отдельные подходы:

### Copying collectors

Вся память делится на "from-space" и "to-space"

Принцип работы:

1) Все объекты попадают в from space
2) Когда from space заполняется, то нужно собрать мусор
3) Приложение приостанавливается
4) В from space находятся живые объекты
5) Живые объекты копирутся в to space
6) from sapce очищается 
7) from space и to space меняются местами

Главный плюс, что объекты полностью забивают память.

Минусы:
+ Приостановка приложения
+ Все объекты могут быть живыми.

### Mark-and-sweep

1) Объекты попадают в память
2) Нужно запустить GC
3) Приложение приостанавливается
4) Сборщик проходится по дереву, помечая живые объекты 
5) Сборщик проходится по все памяти, находя все неотмеченные куски памяти, сохраняя их в free list
6) Новые объекты попадают сраху в память доступную в free list

Минусы:
+ Приложение приостанавливается
+ Время работы зависит от размеров памяти и количества объектов
+ Если не использовать “compacting” память будет использоваться не эффективно

### Попход для HotSpot VM

В HotSpot VM создано 4 сборщика мусора основаных на Generational Garbage Collection:
+ Serial GC
+ Parallel GC
+ CMS GC
+ G1 GS

Рассмотри Serial GC:

Во время работы этого сборщика приложения приостанавливается и продолжает работать после прекращение сборки мусора.

Память делится на три пространства:
+ Young generation.бъекты аллоцируются в этом участке. Обычно имеет сравнительно не большой размер. Очищается часто. Предполагается, что количество объектов переживших сборку будет мало (основывая на “weak generational hypothesis”). Сборку мусора в этом участке называют “minor garbage collection”. В общем, “minor garbage collection” проходит часто, быстро и уничтожает кучу мусора, так как происходит на сравнительно не большом участке памяти который скорее всего содержит много мусора.
+ The old generation. Объекты которые переживают “minor collection” перемещаются в участок памяти называемый “old generation”. Обычно “old generation” больше чем “young generation”. Заполняется этот участок сильно медленней, так как большинство объектов живут не долго. В итоге, сборка мусора в “old generation” (major garbage collection) происходит не часто, но когда происходит, занимает много времени.
+ Permanent generation. Тут хранятся метаданные, классы, интернированные строки, итд.

Новые объекты создаются в "young generation",
пережившие сборку мусора попадают в old generation. Существует “minor GC” и “major GC”.

+ “minor GC” - проходит часто и быстро, в основном работает с “young generation”.
+ “major GC” - проходит редко и долго, в основном работает с “old generation”.

#### minor GC

Для того чтобы Minor GC проходил быстро, необходимо чтобы ему не приходилось сканировать old generation. Чтобы разделить 
old ganeration и young generation в Hotspot VM ввелм структуру card table. 
Память в “old generation” разбивается на карты (cards).

Card table - это массив с однобайтной ячейкой, каждая ячейка массива соответствует куску памяти (карте) в “old generation”. Когда в каком то поле объекта обновляется ссылка, то в “card table” нужная карта помечается как “грязная” (для этого нужна однобайтная ячейка). В итоге при “minor GC” для выявления ссылок “old-to-new” сканируется не весь “old-generation”, а только объекты которые находятся в “грязных” картах.

“Young generation” делится на:

Eden. Кусок памяти, где объекты алоцируются. После сборки мусора “Eden” пустой, мусор должен удалится, а выжившие объекты попасть в “Survivor space”
Survivor space 1,2. То, что в разделе “Copying collectors” называлось “from-space” и “to-space”. Тут находятся объекты, которые выжили при предыдущей сборке мусора, но перед отправкой в “old generation” им дан шанс стать мусором во время следующей сборки.
Survivor space 1 будем называть “from space”, Survivor space 2 - “to space”.

Алгоритм работы очень похож на “Copying collectors”, отличие в том, что появился “Eden”:

+ Начало сборки мусора, приложение приостанавливается.
+ Живые объекты из “Eden” копируются в “to space”.
+ Живые объекты из “from space” копируются в “to space” или в “old generation”, если они достаточно старые.
+ “Eden” и “from space” очищаются, так как в них остался только мусор.
+ “to space” и “from space” меняются местами
+ Приложение продолжает работу.


Коричневый - мусор.
Зеленый - живой объект.

Сборка мусора:

![](http://ggenikus.github.io/images/YoungGen_1.jpg)

После сборки мусора:
![](http://ggenikus.github.io/images/YoungGen_2.jpg)

После “minor gc” “Eden” и “to space” пустые, в “from space” лежат объекты пережившие сборку, немного долгоживущих объектов перекочевало в “old generation”.

#### Major GC

“major GC” работает по принципу “sliding compacting mark-sweep”. Принцип работы похож на “Mark-and-sweep”, но добавляется процедура “compacting”, которая позволяет более эффективно использовать память.

Процедура заключается в перемещении живых объектов к началу “old generation space”, таким образом мусор остается в конце. Для аллокации нужно иметь указатель на последний живой объекты и дальше просто аллоцировать и сдвигать указатель к концу “old generation”.

+ Запускается GC
+ Приложение приостанавливается
+ Сборщик проходится по дереву объектов в “old generation”, помечая живые объекты
+ Сборщик проходится по всей памяти, находя все не отмеченные куски памяти, они помечаются как мусор
+ Все живые объекты сдвигаются к началу “old generation”, мусор становится одним куском памяти, который находится сразу за последним живым объектом
+ Приложение возобновляет свою роботу.

Находим мусор:

![](http://ggenikus.github.io/images/OldGen_1.jpg)

После “compacting”:

![](http://ggenikus.github.io/images/OldGen_2.jpg)

### Материалы
[Garbage Collector](http://ggenikus.github.io/blog/2014/05/04/gc)
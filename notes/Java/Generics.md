# Generics

**Generics** - *это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра.*


Декларация:
`class BoxPrinter<T>`
После имени класса в угловых скобках "<" и ">" указано имя типа "Т", которое может использоваться внутри класса. Фактически Т – это тип, который должен быть определён позже (при создании объекта класса).

### Diamond syntax
Появился начиная с java 7

`Pair<Integer, String> pair = new Pair<>(6, " Apr");` 

### Generic methods

По аналогии с универсальными классами (дженерик-классами), можно создавать универсальные методы (дженерик-методы), то есть методы, которые принимают общие типы параметров. Универсальные методы не надо путать с методами в дженерик-классе. Универсальные методы удобны, когда одна и та же функциональность должна применяться к различным типам.

`public static <T> void fill(List<T> list, T val)`


### Wildcards

 вот такая строка кода не скомпилируется:

`List<Number> intList = new ArrayList<Integer>();` 
Но есть возможность похожей реализации:

`List<?> intList = new ArrayList<Integer>();` 
Под маской мы будем понимать вот эту штуку – "<?>".

`List<?> numList = new ArrayList<Integer>(); 
numList = new ArrayList<String>(); `
Тут не возникнет проблем компиляции. Однако нехорошо, что переменная numList хранит список со строками. Допустим нам нужно так объявить эту переменную, чтобы она хранила только списки чисел. Решение есть:

`List<? extends Number> numList = new ArrayList<Integer>();` 
`numList = new ArrayList<String>();`

Данный код не скомпилируется, а всё из-за того, что с помощью маски мы задали ограничение. Переменная numList может хранить ссылку только на список, содержащий элементы унаследованные от Number, а всё из-за объявления: List<? extends Number> numList. Тут мы видим, как маске задаётся ограничение – теперь numList предназначен для списка с ограниченным количеством типов. 

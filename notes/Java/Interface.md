Interface
=======================================
 В Java класс может иметь только одного родителя, поскольку при множественном наследовании могут возникать конфликты, которые запутывают объектную модель. Например, если у класса есть два родителя, которые имеют одинаковый метод с различной реализацией, то какой из них унаследует новый класс? И какая будет функциональность родительского класса, который лишился своего метода?
 Все эти проблемы не возникают в том случае, если наследуются только абстрактные методы от нескольких родителей. Даже если унаследовано несколько одинаковых методов, все равно у них нет реализации и можно один раз описать тело метода, которое будет использоваться при вызове любого из этих методов.
 
 ## Объявление интерфейсов
 
 Интерфейс может быть объявлен как public и тогда он будет доступен для общего использования, либо модификатор доступа может не указываться, в этом случае интерфейс доступен только для типов своего пакета. Модификатор abstract для интерфейса не требуется, поскольку все интерфейсы являются абстрактными. 
 
 Далее записывается ключевое слово `interface` и имя интерфейса.

После этого может следовать ключевое слово extends и список интерфейсов, от которых будет наследоваться объявляемый интерфейс. Родительских типов может быть много, главное, чтобы не было повторений и чтобы отношение наследования не образовывало циклической зависимости.

Затем в фигурных скобках записывается тело интерфейса.

```
public interface Drawable extends Colorable, 
   Resizable {
}
```

ело интерфейса состоит из объявления элементов, то есть полей-констант и абстрактных методов. Все поля интерфейса должны быть `public final static`, так что эти модификаторы указывать необязательно и даже нежелательно, чтобы не загромождать код. Поскольку поля объявляются финальными, необходимо их сразу инициализировать.
```
public interface Directions {
   int RIGHT=1;
   int LEFT=2;
   int UP=3;
   int DOWN=4;
}
```
Все методы интерфейса являются public abstract и эти модификаторы также необязательны.
```
public interface Moveable {
   void moveRight();
   void moveLeft();
   void moveUp();
   void moveDown();
}
```
## Реализация интерфейса

Каждый класс может реализовывать любые доступные интерфейсы. При этом в классе должны быть реализованы все абстрактные методы, появившиеся при наследовании от интерфейсов или родительского класса, чтобы новый класс мог быть объявлен неабстрактным.


Подобный конфликт с полями-константами не столь критичен:
```
interface A {
  int value=3;
}
interface B {
  double value=5.4;
}
class C implements A, B {
  public static void main(String s[]) {
    C c = new C();
    // System.out.println(c.value); - ошибка!
    System.out.println(((A)c).value);
    System.out.println(((B)c).value);
  }
}
```

## Приминение интерфейсов

*Интерфейс* – это полностью абстрактный класс, в целом верно, но оно не отражает всех преимуществ, которые дают интерфейсы объектной модели. Как уже отмечалось, множественное наследование порождает ряд конфликтов, но отказ от него, хоть и делает язык проще, но не устраняет ситуации, в которых требуются подобные подходы.

Рассмотрим такое свойство живого организма, как способность питаться насекомыми. Очевидно, что это свойство нельзя приписать всей группе птиц, или млекопитающих, а тем более растений. Но существуют представители каждой из названных групп, которые этим свойством обладают, – для растений это росянка, для птиц, например, ласточки, а для млекопитающих – муравьеды. Причем, очевидно, "реализовано" это свойство у каждого вида совсем по-разному.

Можно было бы объявить соответствующий метод (скажем, `consumeInsect(Insect)` ) у каждого представителя независимо. Но если задача состоит в моделировании, например, зоопарка, то однотипную процедуру – кормление насекомыми – пришлось бы описывать для каждого вида отдельно, что существенно осложнило бы код, причем без какой-либо пользы.

Java предлагает другое решение. Объявляется интерфейс InsectConsumer:
```
public interface InsectConsumer {
   void consumeInsect(Insect i);
}
```
Его реализуют все подходящие животные и растения:

// росянка расширяет класс растение
```
public class Sundew extends 
   Plant implements InsectConsumer {
      public void consumeInsect(Insect i) {
      ...
      }
}
```
// ласточка расширяет класс птица
```
public class Swallow extends 
   Bird implements InsectConsumer {
      public void consumeInsect(Insect i) {
      ...
      }
}
```
// муравьед расширяет класс млекопитающее
```
public class AntEater extends 
   Mammal implements InsectConsumer {
      public void consumeInsect(Insect i) {
      ...
      }
}
```
В результате в классе, моделирующем служащего зоопарка, можно объявить соответствующий метод:

// служащий, отвечающий за кормление, 
// расширяет класс служащий
```
class FeedWorker extends Worker {

   // с помощью этого метода можно накормить
   // и росянку, и ласточку, и муравьеда
   public void feedOnInsects(InsectConsumer 
                             consumer) {
      ...
      consumer.consumeInsect(insect);
      ...
   }
}
```
В результате удалось свести работу с одним свойством трех разнородных классов в одно место, сделать код более универсальным. Обратите внимание, что при добавлении еще одного насекомоядного такая модель зоопарка не потребует никаких изменений, чтобы обслуживать новый вид, в отличие от первоначального громоздкого решения. Благодаря введению интерфейса удалось отделить классы, реализующие его (живые организмы) и использующие его (служащий зоопарка). После любых изменений этих классов при условии сохранения  интерфейса их взаимодействие не нарушится.

## Абстрактный класс vs Interface
Короткое различие.

Абстрактный класс — это класс, у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами).

Интерфейс — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

Интерфейс нужен обычно когда описывается только интерфейс (тавтология). Например, один класс хочет дать другому возможность доступа к некоторым своим методам, но не хочет себя «раскрывать». Поэтому он просто реализует интерфейс.

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода.

